% ========================================
% 
% ========================================
\section{MIPS}
\begin{frame}{\acs{MIPS}}{}
  \begin{itemize}
  \item \ac{MIPS} is a \ac{RISC}-type \ac{uP}.
  \item \ac{MIPS} could use either 32- or 64-bits data widths.
    \begin{itemize}
	\item We will focus on 32-bit \ac{MIPS}.
	\end{itemize}
  \item Supports 3 instruction types.
    \begin{itemize}
    \item R-Type for register-register operations.
    \item I-Type for immediate operations.
    \item J-Type for jump operations.
    \end{itemize}
  \end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{}
  \begin{figure}
  \centering
  \includegraphics[width=\textwidth]{MIPS_instruction_types}
  \caption{\acs{MIPS}32 instruction types.}
  \label{Figure:MIPS32_instruction_types}
  \end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{}
  \begin{figure}
  \centering
  \includegraphics[scale=0.28]{MIPS32_integer_instructions}
  \vspace{-8pt}
  \caption{\acs{MIPS}32 integer instructions.}
  \label{Figure:MIPS32_integer_instructions}
  \end{figure}
\end{frame}

% sll/srl/sra rd, rt, sa # rd <-- rt shift sa
% lui rt, immediate # rt <-- immediate << 16
% lw rt, offset(rs) # rt <-- memory[rs + offset]
% sw rt, offset(rs) # memory[rs + offset] <-- rt
% bne rs, rt, label # if (rs != rt) PC <-- label
% j target # PC <-- target
% jr rs # PC <-- rs
% ========================================
% 
% ========================================
\begin{frame}{\acs{MIPS} instruction examples}
  \begin{table}[htbp]
  \caption{MIPS instruction examples}
  \label{Table:MIPS_instruction_examples}
    \begin{tabular}{llll|l}
    \hline\hline
    \multicolumn{4}{c|}{\textbf{Instruction}} & \textbf{Meaning} \\\hline
      \code{add} & \code{rd,} & \code{rs,} & \code{rt} & \code{rd} $\leftarrow$ \code{rs + rt} \\\hline 
    \code{addi} & \code{rt,} & \code{rs,} & \code{imm} & \code{rt} $\leftarrow$ \code{rs + (sign\_ext)imm} \\\hline 
    \code{ori} & \code{rt,} & \code{rs,} & \code{imm} & \code{rt} $\leftarrow$ \code{rs | (zero\_ext)imm} \\\hline 
    \code{sra} & \code{rd,} & \code{rt,} & \code{sa} & \code{rd} $\leftarrow$ \code{rt << sa} \\\hline 
    \code{lui} & \code{rt,} & \multicolumn{2}{l|}{\code{imm}} & \code{rt} $\leftarrow$ \code{imm << 16} \\\hline 
    \code{lw} & \code{rt,} & \multicolumn{2}{l|}{\code{offset(rs)}} & \code{rt} $\leftarrow$ \code{memory[rs + offset]} \\\hline 
    \code{sw} & \code{rt,} & \multicolumn{2}{l|}{\code{offset(rs)}} & \code{memory[rs + offset]} $\leftarrow$ \code{rt} \\\hline 
    \code{bne} & \code{rs,} & \code{rt,} & \code{label} & \code{if (rs != rt) then PC} $\leftarrow$ \code{label} \\\hline
    \code{j} & \multicolumn{3}{l|}{\code{target}} & \code{PC} $\leftarrow$ \code{target} \\\hline
    \code{jr} & \multicolumn{3}{l|}{\code{rs}} & \code{PC} $\leftarrow$ \code{rs} \\\hline 
    \end{tabular}
  \end{table}
\end{frame}

\section{Building a \acl{uP}}
% ========================================
% 
% ========================================
\begin{frame}{Generalised \ac{uP}}
  \begin{figure}
  \centering
  \includegraphics[width=\textwidth]{non_pipelined_cpu}
  \caption{Generalised \ac{uP} schematic.}
  \label{Figure:non_pipelined_cpu}
  \end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Generalised \ac{uP}}
  \begin{figure}
  \centering
  \includegraphics[width=\textwidth]{non_pipelined_cpu_stages}
  \caption{Stages of a \ac{uP} cycle.}
  \label{Figure:non_pipelined_cpu_stages}
  \end{figure}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{Stages of a \ac{uP} instruction cycle}
\begin{enumerate}
\item \acbf{IF}. Instructions are read from \ac{IM}.
\item \acbf{ID}. Type of operation and operands are defined.
\item \acbf{EXE}. Operands are used in order to perform arithmetic or logical operations.
\item \acbf{MEM}. Data is read/written from/to \ac{DM}.
\item \acbf{WB}. Results from \ac{EXE} or \ac{MEM} stages are written back into \ac{RF}.
\end{enumerate}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{\ac{uA} of a \ac{MIPS}}
\begin{itemize}
\item We will begin to design the \acf{uA} for each stage of a \ac{uP} instruction cycle.
\item We will focus on a single-cycle \ac{uP} at first.
\item During this course, we will include the \ac{HW} necessary in order to complete a pipelined \ac{uP}. 
\end{itemize}
\end{frame}

\section{\acl{IF}}
% ========================================
% 
% ========================================
\begin{frame}{\acl{IF}}
  \begin{figure}
  \centering
  \includegraphics[scale=1.5]{non_pipelined_IF}
  \caption{Basic diagram of \ac{IF} stage.}
  \label{Figure:non_pipelined_IF}
  \end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{R-Type arithmetic/logic instruction}
  \begin{figure}
  \centering
  \includegraphics[scale=0.9]{non_pipelined_MIPS_Rtype_ADD}
  \vspace{-1pt}
  \caption{\ac{uA} of \ac{MIPS} R-Type arithmetic/logic instructions.}
  \label{Figure:non_pipelined_MIPS_Rtype_ADD}
  \end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{R-Type arithmetic/logic instructions}
\begin{itemize}
\item \ac{ALU} takes its operands \code{a} and \code{b} from outputs \code{Qa} and \code{Qb} from \ac{RF}, respectively.
\item A control unit asserts \code{alu\_op} according to the type of operation to be performed, \ie, \code{add}, \code{sub}, \code{and}, \code{or} or \code{xor}. 
\item Control unit asserts \code{rf\_we} in order to write the \code{alu\_result} back into \ac{RF}.
\end{itemize}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{R-Type shift instructions}
  \begin{figure}
  \centering
  \includegraphics[scale=0.9]{non_pipelined_MIPS_Rtype_SHIFT}
  \vspace{-3pt}
  \caption{\ac{uA} of a \ac{MIPS} R-Type shift instruction.}
  \label{Figure:non_pipelined_MIPS_Rtype_SHIFT}
  \end{figure}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{R-Type shift instructions}
\begin{itemize}
\item Input \code{a} in \ac{ALU} represents shift amount \code{sa}.
\item Here, the 27 \acp{MSB} of \code{sa} are ignored.
\item Similarly, \code{rs} is not used.
\end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{I-Type arithmetic/logic instructions}
  \begin{figure}
  \centering
  \includegraphics[scale=0.9]{non_pipelined_MIPS_Itype_ADD}
  \vspace{-3pt}
  \caption{\ac{uA} of a \ac{MIPS} I-Type arithmetic/logic instruction.}
  \label{Figure:non_pipelined_MIPS_Itype_ADD}
  \end{figure}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{I-Type arithmetic/logic instructions}
\begin{itemize}
\item \code{rd} is not used.
\item \code{imm} must be sign/zero extended. 
\end{itemize}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{I-Type load/store instructions}
  \begin{figure}
  \centering
  \includegraphics[scale=0.68]{non_pipelined_MIPS_Itype_LOAD}
  \vspace{-3pt}
  \caption{\ac{uA} of a \ac{MIPS} I-Type load/store instruction.}
  \label{Figure:non_pipelined_MIPS_Itype_LOAD}
  \end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{I-Type load/store instructions}
\begin{itemize}
\item \ac{ALU} will perform calculations in order to find the address to read/write data from/to.
\item Control unit provides a \code{dm\_we} signal, which is a write enable for reading/writing from \ac{DM}.
\end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{I-Type conditional branch instructions}
  \begin{figure}
  \centering
  \includegraphics[scale=0.78]{non_pipelined_MIPS_Itype_BRANCH}
  \vspace{-3pt}
  \caption{\ac{uA} of a \ac{MIPS} I-Type conditional branch instruction.}
  \label{Figure:non_pipelined_MIPS_Itype_BRANCH}
  \end{figure}
\end{frame}

% ========================================
%
% ========================================
\begin{frame}{I-Type load/store instructions}
\begin{itemize}
\item \code{rs} and \code{rt} are compared in order to determine whether to branch or not.
\item If the branch is taken, \ac{PC} is updated with the branch target address, which is the sum of the current value of \ac{PC} and an \code{imm} value.
\item There is no write-back to \ac{RF}.
\end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{J-Type instructions}
  \begin{figure}
  \centering
  \includegraphics[scale=0.78]{non_pipelined_MIPS_Jtype_JUMP}
  \vspace{-3pt}
  \caption{\ac{uA} of a \ac{MIPS} J-Type jump instruction.}
  \label{Figure:non_pipelined_MIPS_Jtype_JUMP}
  \end{figure}
\end{frame}