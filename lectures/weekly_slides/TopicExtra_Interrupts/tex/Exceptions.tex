\section{Exceptions \& Interrupts}
% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item Exceptions and interrupts are unexpected events that disrupt the normal execution of a program. 
\item They are not \code{branch} or \code{jump} instructions executed in a program. 
\item They transfer the control of the \ac{CPU} to a special program, known as \alertblue{handler}.
\item The handler is a set of instructions programmed in the \ac{OS} kernel.
\item The handler may decide to terminate the program or to resume its execution.

%\item Exceptions and interruptions are mistakenly used as interchangeable terms. However, they differ from each other.
%\item The difference between an exception and an interrupt is the source that triggered the change in the flow control. 
\end{itemize}
\end{frame} 

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item The basic flow of exception/interrupts is as follows.
\begin{enumerate}
\item An instruction triggers an exception or an interrupt occurs.
\item Control of the program is transferred to a handler.
\item The handler deals with the unexpected event by either
\begin{enumerate}
\item providing service to the user program by taking predetermined actions, for example responding to an arithmetic overflow. 
After the handler finishes its execution, \ac{OS} kernel releases control back to the main program and the execution resumes.
\item[] OR
\item stopping the execution of the suspended program and report an error to the user.
\end{enumerate}
\end{enumerate}
%\item Exceptions and interruptions are mistakenly used as interchangeable terms. However, they differ from each other.
%\item The difference between an exception and an interrupt is the source that triggered the change in the flow control. 
\end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{interrupt_basic}
\caption{Exceptions and interruptions flow control.}
\label{Figure:Interruption_basic}
\end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item \alertblue{Exceptions} are \alertblue{synchronous} unscheduled events that occur \alertblue{internally} to the processor.
\pauseprint
  \begin{itemize}
  \item Arithmetic overflow.
  \item Unsupported instruction.
  \end{itemize}
\pauseprint
\item \alertred{Interrupts} are \alertred{asynchronous} unscheduled events that occur \alertred{externally} to the processor.
\pauseprint
  \begin{itemize}
  \item \ac{IO} devices such as keyboard or mouse.
  \item Timers.
  \end{itemize}
\end{itemize}
\end{frame} 

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
Is the following example an interrupt or an exception?
\begin{itemize}
\item Our ARMv-6M design can only perform eight instructions.
  \begin{itemize}
  %\pauseprint
  \item What would happen in our design if the \ac{uP} receives a \code{cmp} instruction?
  \end{itemize}
\end{itemize}
\end{frame} 

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item In order to handle an exception, we must know
\begin{enumerate}
\item The reason for the exception.
\item The instruction that cause the exception.
\end{enumerate}
\item There are two ways of knowing this.
  \begin{enumerate}
  \item Polled.
  \item Vectored.
  \end{enumerate}
\end{itemize}
\end{frame} 

%\item \ac{MIPS} \ac{uA} uses a special register called \alertblue{Cause register}.
%\begin{itemize}
%\item A field in this register indicates the reason for the exception.
%\end{itemize}

%For the operating system to handle the exception, it must know the reason for
%the exception, in addition to the instruction that caused it. Tere are two main
%methods used to communicate the reason for an exception. Te method used in
%the MIPS architecture is to include a status register (called the Cause register),
%which holds a feld that indicates the reason for the exception.
%A second method, is to use vectored interrupts. In a vectored interrupt, the
%address to which control is transferred is determined by the cause of the exception


% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item \acp{uP} usually rely on special registers for handling exceptions and nterrupts.
\item In \ac{MIPS} \ac{uA}, this register is the \ac{EPC}.
\item \ac{EPC} stores the address of the instruction that caused the exception before transferring flow control to the program handler.
\item The handler may then provide service to the offending program with a redefined action.
\item If the handler does not terminate the main program execution, it uses the \ac{EPC} in order to return control to the main program and resume its execution.
\end{itemize}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\alertblue{Polled exceptions/interrupts}
\begin{itemize}
\item \ac{MIPS} \ac{uA} provides a status register, called \textbf{Cause Register}, which holds a field that indicates the reason for the exception/interrupt.
\item \ac{CPU} must first read the cause register in order to identify the reason of the exception/interrupt.
\end{itemize}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{cause_register}
\caption{Cause register example.}
\label{Figure:CauseRegister}
\end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{figure}
\centering
\includegraphics[scale=0.59]{ExcCode}
\vspace{-10pt}
\caption{Causes of exceptions in \ac{MIPS} \ac{uA}.}
\label{Figure:ExcCode}
\end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item In polled exceptions/interrupts, the control transfer is done in two steps.
  \begin{enumerate}
  \item Control is transferred to a common entry address.
  \item Control is then transferred to an individual address corresponding to the ExcCode handler.
  \end{enumerate}
\item In \alertblue{vectored exceptions/interrupts}, the address to which control is transferred to is determined by the cause of the exception.
\end{itemize}
\begin{table}
\caption{Example of vectored exceptions}
\label{Table:vectored_interrupt_examples}
\begin{tabular}{l|l}
\hline\hline
Exception type        & Exception vector address \\\hline
Undefined instruction & 0x80000000 \\\hline
Arithmetic overflow   & 0x80000180 \\\hline\hline
\end{tabular}
\end{table}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{vectored_interrupt}
\caption{Mechanisms for vectored interrupts.}
\label{Figure:vectored_interrupt}
\end{figure}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\alertblue{Key points to remember}
\begin{itemize}
  \item Polled.
  \begin{itemize}
    \item \ac{CPU} needs to constantly read cause register in order to identify if an exception/interrupt has occurred.
    \item \ac{CPU} does not directly know the source of the exception/interrupt.
    \item Requires reading cause register for identifying the source.
    \item After reading the cause register, control is given to handler.
  \end{itemize}
  \item Vectored.
    \begin{itemize}
    \item Exception/interrupt signal includes the source.
    \end{itemize} 
\end{itemize} 
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item How does a handler return the control to the main program?
\pauseprint
\item The return address must be saved prior entering the handler's routine.
\item Based on the \acp{ISA}, the return address may be saved to
\begin{itemize}
\item A general-purpose register.
\item A special register.
\item Stack memory.
\end{itemize} 

\end{itemize}
\end{frame}


% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item Exceptions store the current \ac{PC} value.
\begin{itemize}
\item This is done in case the offending instructions needs to be executed again.
\end{itemize}
\item Interrupts, on the other hand, store the \alertblue{next} \ac{PC} value.
\begin{itemize}
\item Current instruction is completed before transferring control to handler.
\end{itemize}
\end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{exceptions_EPC}
\caption{Return address in exceptions and interruptions.}
\label{Figure:exception_EPC}
\end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item \ac{MIPS} provides the special instruction \code{eret} for returning from exception handler.
\item This instruction writes into \ac{PC} the contents of \ac{EPC}.
\item If the offending instruction does not need to be executed again, the return address is incremented before being loaded into \ac{PC}.
\end{itemize}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item Interrupts may occur any time, even when the handler is executing an interrupt subroutine.
\item These further interrupt request may be enabled or disabled with a special control register.
\end{itemize}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{interrupt_masking}
\caption{Interrupt masking in Status register.}
\label{Figure:interrupt_masking}
\end{figure}
\begin{itemize}
\item The $i^{\mathrm{th}}$ bit in \code{IM} field represents the  $i^{\mathrm{th}}$ interruption request.
\item Bit \code{IE} is the global interrupt enable.
\item When an interrupt is attended, \ac{uP} may or may not disable (mask) all other \code{IM} bits, based on whether the \ac{uP} supports nested interrupts.
\end{itemize}
\end{frame}
% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\begin{itemize}
\item If nested interrupts are supported, some states, including return addresses must be saved to the stack memory.
\item Moreover, some interrupts may have priority over others. For example, timers have priority over keyboard inputs.
\end{itemize}
\begin{figure}
\centering
\includegraphics[width=\textwidth]{interrupt_nesting}
\caption{Interrupt nesting.}
\label{Figure:interrupt_nesting}
\end{figure}
\end{frame}

% ========================================
% 
% ========================================
\begin{frame}{Exceptions \& Interrupts}{}
\alertblue{Summary}
\begin{itemize}
\item Interrupts and exceptions are not the same.
\item Interrupt/exception handler.
\item Polled vs Vectored.
\item \ac{EPC}.
\end{itemize}
\end{frame}

